// 20251219 chatGPT生成
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris (Browser)</title>
  <style>
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", sans-serif; background:#0f0f12; color:#e6e6eb; }
    .wrap { display:flex; gap:16px; padding:16px; align-items:flex-start; justify-content:center; flex-wrap:wrap; }
    canvas { background:#0f0f12; border:1px solid #2a2a33; border-radius:10px; }
    .panel { width: 280px; padding:12px 14px; background:#15151b; border:1px solid #2a2a33; border-radius:12px; }
    .panel h1 { font-size:18px; margin:0 0 10px; }
    .row { display:flex; justify-content:space-between; margin:6px 0; }
    .hint { font-size:12px; opacity:.85; line-height:1.6; margin-top:10px; }
    button {
      cursor:pointer; padding:10px 12px; border-radius:10px; border:1px solid #2a2a33;
      background:#1b1b22; color:#e6e6eb; width:100%; margin-top:10px;
    }
    button:hover { background:#22222b; }
    .small { font-size:12px; opacity:.9; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="300" height="600"></canvas>

    <div class="panel">
      <h1>テトリス (ブラウザ版)</h1>

      <div class="row"><div>Score</div><div id="score">0</div></div>
      <div class="row"><div>Lines</div><div id="lines">0</div></div>
      <div class="row"><div>Level</div><div id="level">1</div></div>
      <div class="row"><div class="small">Status</div><div class="small" id="status">PLAY</div></div>

      <button id="btnPause">P: Pause / Resume</button>
      <button id="btnRestart">R: Restart</button>

      <div class="hint">
        <b>操作</b><br/>
        ← →：移動 / ↑：回転 / ↓：ソフトドロップ<br/>
        Space：ハードドロップ / P：一時停止 / R：リスタート
        <hr style="border:none;border-top:1px solid #2a2a33; margin:12px 0;">
        <b>コツ</b>：穴を作らない・平らに積む・欲張らない
      </div>
    </div>
  </div>

<script>
(() => {
  // ----- Config -----
  const COLS = 10, ROWS = 20;
  const CELL = 30;
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const elScore = document.getElementById("score");
  const elLines = document.getElementById("lines");
  const elLevel = document.getElementById("level");
  const elStatus = document.getElementById("status");
  const btnPause = document.getElementById("btnPause");
  const btnRestart = document.getElementById("btnRestart");

  const BG = "#0f0f12";
  const GRID = "#2a2a33";
  const COLORS = {
    I: "#00ffff",
    J: "#0000ff",
    L: "#ffa500",
    O: "#ffff00",
    S: "#00ff00",
    T: "#a020f0",
    Z: "#ff0000"
  };

  // 4x4 rotation states
  const SHAPES = {
    I: [
      ["....","####","....","...."],
      ["..#.","..#.","..#.","..#."]
    ],
    J: [
      ["#...","###.","....","...."],
      [".##.",".#..",".#..","...."],
      ["....","###.","..#.","...."],
      [".#..",".#..","##..","...."]
    ],
    L: [
      ["..#.","###.","....","...."],
      [".#..",".#..",".##.","...."],
      ["....","###.","#...","...."],
      ["##..",".#..",".#..","...."]
    ],
    O: [
      [".##.",".##.","....","...."]
    ],
    S: [
      [".##.","##..","....","...."],
      [".#..",".##.","..#.","...."]
    ],
    T: [
      [".#..","###.","....","...."],
      [".#..",".##.",".#..","...."],
      ["....","###.",".#..","...."],
      [".#..","##..",".#..","...."]
    ],
    Z: [
      ["##..",".##.","....","...."],
      ["..#.",".##.",".#..","...."]
    ]
  };

  const KEYS = Object.keys(SHAPES);

  // ----- Helpers -----
  const makeBoard = () => Array.from({length: ROWS}, () => Array(COLS).fill(null));

  function newBag() {
    const bag = KEYS.slice();
    for (let i = bag.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [bag[i], bag[j]] = [bag[j], bag[i]];
    }
    return bag;
  }

  function shapeToCells(grid, ox, oy) {
    const out = [];
    for (let y = 0; y < 4; y++) {
      for (let x = 0; x < 4; x++) {
        if (grid[y][x] === "#") out.push([ox + x, oy + y]);
      }
    }
    return out;
  }

  function valid(board, cells) {
    for (const [x,y] of cells) {
      if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
      if (board[y][x] !== null) return false;
    }
    return true;
  }

  function lock(board, cells, color) {
    for (const [x,y] of cells) board[y][x] = color;
  }

  function clearLines(board) {
    const kept = board.filter(row => row.some(c => c === null));
    const cleared = ROWS - kept.length;
    while (kept.length < ROWS) kept.unshift(Array(COLS).fill(null));
    return { board: kept, cleared };
  }

  function draw() {
    ctx.fillStyle = BG;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // grid + blocks
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const px = x * CELL, py = y * CELL;
        ctx.strokeStyle = GRID;
        ctx.strokeRect(px, py, CELL, CELL);

        const c = board[y][x];
        if (c) {
          ctx.fillStyle = c;
          ctx.fillRect(px+1, py+1, CELL-2, CELL-2);
        }
      }
    }

    // active piece
    if (!gameOver) {
      const cells = shapeToCells(SHAPES[piece.k][piece.rot], piece.x, piece.y);
      ctx.fillStyle = piece.color;
      for (const [x,y] of cells) {
        const px = x * CELL, py = y * CELL;
        ctx.fillRect(px+1, py+1, CELL-2, CELL-2);
      }
    }

    // overlays
    ctx.fillStyle = "#e6e6eb";
    ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.fillText(`Score: ${score}`, 10, 22);
    ctx.fillText(`Lines: ${lines}`, 10, 42);
    ctx.fillText(`Level: ${level}`, 10, 62);

    if (paused) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#e6e6eb";
      ctx.font = "28px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("PAUSED", canvas.width/2, canvas.height/2);
      ctx.textAlign = "left";
    }
    if (gameOver) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#ff6a6a";
      ctx.font = "22px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2 - 10);
      ctx.fillStyle = "#e6e6eb";
      ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.fillText("Press R to restart", canvas.width/2, canvas.height/2 + 20);
      ctx.textAlign = "left";
    }
  }

  // ----- Game State -----
  let board, bag, piece;
  let score = 0, lines = 0, level = 1;
  let paused = false, gameOver = false;
  let lastTime = 0, fallAcc = 0;

  function spawn() {
    if (!bag.length) bag = newBag();
    const k = bag.pop();
    const rot = 0;
    const x = (COLS / 2 | 0) - 2;
    const y = 0;
    const color = COLORS[k];
    return { k, rot, x, y, color };
  }

  function reset() {
    board = makeBoard();
    bag = newBag();
    piece = spawn();
    score = 0; lines = 0; level = 1;
    paused = false; gameOver = false;
    fallAcc = 0;
    updateUI();
    draw();
  }

  function updateUI() {
    elScore.textContent = score;
    elLines.textContent = lines;
    elLevel.textContent = level;
    elStatus.textContent = gameOver ? "GAME OVER" : (paused ? "PAUSED" : "PLAY");
  }

  function fallMs() {
    // faster as level increases
    return Math.max(80, 650 - (level - 1) * 55);
  }

  function tryMove(dx, dy) {
    const cells = shapeToCells(SHAPES[piece.k][piece.rot], piece.x + dx, piece.y + dy);
    if (valid(board, cells)) {
      piece.x += dx; piece.y += dy;
      return true;
    }
    return false;
  }

  function tryRotate() {
    const nextRot = (piece.rot + 1) % SHAPES[piece.k].length;
    // simple wall-kick
    const tests = [[0,0], [-1,0], [1,0], [-2,0], [2,0]];
    for (const [dx,dy] of tests) {
      const cells = shapeToCells(SHAPES[piece.k][nextRot], piece.x + dx, piece.y + dy);
      if (valid(board, cells)) {
        piece.rot = nextRot;
        piece.x += dx; piece.y += dy;
        return true;
      }
    }
    return false;
  }

  function hardDrop() {
    if (gameOver || paused) return;
    while (tryMove(0, 1)) score += 2;
    // lock
    lockCurrent();
  }

  function lockCurrent() {
    const cellsNow = shapeToCells(SHAPES[piece.k][piece.rot], piece.x, piece.y);
    lock(board, cellsNow, piece.color);
    const res = clearLines(board);
    board = res.board;

    if (res.cleared) {
      lines += res.cleared;
      const add = [0, 100, 300, 500, 800][res.cleared] * level;
      score += add;
      level = 1 + Math.floor(lines / 10);
    }

    piece = spawn();
    if (!valid(board, shapeToCells(SHAPES[piece.k][piece.rot], piece.x, piece.y))) {
      gameOver = true;
    }
    updateUI();
  }

  // ----- Input -----
  window.addEventListener("keydown", (e) => {
    if (e.code === "KeyP") {
      paused = !paused;
      updateUI();
      draw();
      return;
    }
    if (e.code === "KeyR") {
      reset();
      return;
    }
    if (gameOver || paused) return;

    switch (e.code) {
      case "ArrowLeft":  tryMove(-1, 0); break;
      case "ArrowRight": tryMove(1, 0); break;
      case "ArrowDown":  if (tryMove(0, 1)) score += 1; break;
      case "ArrowUp":    tryRotate(); break;
      case "Space":      hardDrop(); break;
      default: return;
    }
    updateUI();
    draw();
  });

  btnPause.addEventListener("click", () => {
    paused = !paused;
    updateUI();
    draw();
  });
  btnRestart.addEventListener("click", () => reset());

  // ----- Loop -----
  function tick(ts) {
    const dt = ts - lastTime;
    lastTime = ts;

    if (!paused && !gameOver) {
      fallAcc += dt;
      if (fallAcc >= fallMs()) {
        fallAcc = 0;
        if (!tryMove(0, 1)) {
          lockCurrent();
        }
      }
    }

    draw();
    requestAnimationFrame(tick);
  }

  reset();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
